import {
  spring
} from "./chunk-FINBWSCW.js";
import "./chunk-ELKJSBLM.js";
import "./chunk-WQDPC2SN.js";
import "./chunk-B7HYCXRA.js";
import "./chunk-XF5MMYSG.js";
import "./chunk-7RQDXF5S.js";
import "./chunk-7KJFABNG.js";
import "./chunk-33EVKKU6.js";
import {
  cubicInOut,
  quadInOut
} from "./chunk-YERFD2CZ.js";
import {
  add_locations,
  append_styles,
  attribute_effect,
  bind_prop,
  bind_this,
  bind_window_scroll,
  bind_window_size,
  check_target,
  cleanup_styles,
  derived,
  hmr,
  init,
  legacy_api,
  legacy_rest_props,
  onMount,
  prop,
  setup_stores,
  slot,
  store_get,
  store_set,
  validate_store,
  writable
} from "./chunk-LSDIFO3X.js";
import {
  append,
  from_html
} from "./chunk-QSMT42QS.js";
import {
  $window,
  FILENAME,
  HMR,
  child,
  deep_read_state,
  event,
  get,
  getContext,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mutable_source,
  pop,
  push,
  reset,
  set,
  setContext,
  strict_equals,
  untrack
} from "./chunk-PPMGFJ2N.js";
import "./chunk-L3IDHH4W.js";
import "./chunk-U7P2NEEE.js";
import "./chunk-K63UQA3V.js";
import "./chunk-UGBVNEQM.js";

// node_modules/svelte-parallax/src/utils/writableSet.js
function writableSet(value = /* @__PURE__ */ new Set()) {
  const store = writable(value);
  const wrap = (method) => {
    return (...args) => {
      let output;
      store.update((value2) => {
        output = value2[method](...args);
        return value2;
      });
      return output;
    };
  };
  return {
    ...store,
    add: wrap("add"),
    delete: wrap("delete")
  };
}

// node_modules/svelte-parallax/src/utils/contextKey.js
var contextKey = {};

// node_modules/svelte-parallax/src/utils/clamp.js
var clamp = (val, min, max) => {
  return val < min ? min : val > max ? max : val;
};

// node_modules/svelte-parallax/src/scroll-fork/helper.js
var supportsPassive = false;
try {
  let opts = Object.defineProperty({}, "passive", {
    get: function() {
      supportsPassive = true;
    }
  });
  window.addEventListener("test", null, opts);
} catch (e) {
}
var helper_default = {
  $(selector) {
    if (typeof selector === "string") {
      return document.querySelector(selector);
    }
    return selector;
  },
  extend(...args) {
    return Object.assign(...args);
  },
  addListeners(element, events, handler, opts = { passive: false }) {
    if (!(events instanceof Array)) {
      events = [events];
    }
    for (let i = 0; i < events.length; i++) {
      element.addEventListener(
        events[i],
        handler,
        supportsPassive ? opts : false
      );
    }
  },
  removeListeners(element, events, handler) {
    if (!(events instanceof Array)) {
      events = [events];
    }
    for (let i = 0; i < events.length; i++) {
      element.removeEventListener(events[i], handler);
    }
  },
  cumulativeOffset(element) {
    let top = 0;
    let left = 0;
    do {
      top += element.offsetTop || 0;
      left += element.offsetLeft || 0;
      element = element.offsetParent;
    } while (element);
    return {
      top,
      left
    };
  },
  directScroll(element) {
    return element && element !== document && element !== document.body;
  },
  scrollTop(element, value) {
    let inSetter = value !== void 0;
    if (this.directScroll(element)) {
      return inSetter ? element.scrollTop = value : element.scrollTop;
    } else {
      return inSetter ? document.documentElement.scrollTop = document.body.scrollTop = value : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
    }
  },
  scrollLeft(element, value) {
    let inSetter = value !== void 0;
    if (this.directScroll(element)) {
      return inSetter ? element.scrollLeft = value : element.scrollLeft;
    } else {
      return inSetter ? document.documentElement.scrollLeft = document.body.scrollLeft = value : window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
    }
  }
};

// node_modules/svelte-parallax/src/scroll-fork/svelteScrollTo.js
var defaultOptions = {
  container: "body",
  duration: 500,
  delay: 0,
  offset: 0,
  easing: cubicInOut,
  onStart: void 0,
  onDone: void 0,
  onAborting: void 0,
  scrollX: false,
  scrollY: true
};
var abortEvents = [
  "mousedown",
  "wheel",
  "DOMMouseScroll",
  "mousewheel",
  "keydown",
  "touchmove"
];
var _scrollTo = (options) => {
  let {
    offset,
    duration,
    delay,
    easing,
    x = 0,
    y = 0,
    scrollX,
    scrollY,
    onStart,
    onDone,
    container,
    onAborting,
    element
  } = options;
  if (typeof offset === "function") {
    offset = offset();
  }
  const cumulativeOffsetContainer = helper_default.cumulativeOffset(container);
  const cumulativeOffsetTarget = element ? helper_default.cumulativeOffset(element) : { top: y, left: x };
  const initialX = helper_default.scrollLeft(container);
  const initialY = helper_default.scrollTop(container);
  const targetX = cumulativeOffsetTarget.left - cumulativeOffsetContainer.left + offset;
  const targetY = cumulativeOffsetTarget.top - cumulativeOffsetContainer.top + offset;
  const diffX = targetX - initialX;
  const diffY = targetY - initialY;
  let scrolling = true;
  let started = false;
  let start_time = (void 0)() + delay;
  let end_time = start_time + duration;
  function scrollToTopLeft(element2, top, left) {
    if (scrollX) helper_default.scrollLeft(element2, left);
    if (scrollY) helper_default.scrollTop(element2, top);
  }
  function start(delayStart) {
    if (!delayStart) {
      started = true;
      onStart(element, { x, y });
    }
    helper_default.addListeners(container, abortEvents, stop, { passive: true });
  }
  function tick(progress) {
    scrollToTopLeft(
      container,
      initialY + diffY * progress,
      initialX + diffX * progress
    );
  }
  function stop() {
    scrolling = false;
    helper_default.removeListeners(container, abortEvents, stop);
  }
  (void 0)((now2) => {
    if (!started && now2 >= start_time) {
      start(false);
    }
    if (started && now2 >= end_time) {
      tick(1);
      stop();
      onDone(element, { x, y });
      return false;
    }
    if (!scrolling) {
      onAborting(element, { x, y });
      return false;
    }
    if (started) {
      const p = now2 - start_time;
      const t = 0 + 1 * easing(p / duration);
      tick(t);
    }
    return true;
  });
  start(delay);
  tick(0);
  return stop;
};
var proceedOptions = (options) => {
  let opts = helper_default.extend({}, defaultOptions, options);
  opts.container = helper_default.$(opts.container);
  opts.element = helper_default.$(opts.element);
  return opts;
};
var scrollContainerHeight = (containerElement) => {
  if (containerElement && containerElement !== document && containerElement !== document.body) {
    return containerElement.scrollHeight - containerElement.offsetHeight;
  } else {
    let body = document.body;
    let html = document.documentElement;
    return Math.max(
      body.scrollHeight,
      body.offsetHeight,
      html.clientHeight,
      html.scrollHeight,
      html.offsetHeight
    );
  }
};
var scrollTo = (options) => {
  return _scrollTo(proceedOptions(options));
};
var scrollToBottom = (options) => {
  options = proceedOptions(options);
  return _scrollTo(
    helper_default.extend(options, {
      element: null,
      y: scrollContainerHeight(options.container)
    })
  );
};
var scrollToTop = (options) => {
  options = proceedOptions(options);
  return _scrollTo(
    helper_default.extend(options, {
      element: null,
      y: 0
    })
  );
};
var makeScrollToAction = (scrollToFunc) => {
  return (node, options) => {
    let current = options;
    const handle = (e) => {
      e.preventDefault();
      scrollToFunc(
        typeof current === "string" ? { element: current } : current
      );
    };
    helper_default.addListeners(node, ["click", "touchstart"], handle);
    return {
      update(options2) {
        current = options2;
      },
      destroy() {
        helper_default.removeListeners(node, ["click", "touchstart"], handle);
      }
    };
  };
};
var scrollto = makeScrollToAction(scrollTo);
var scrolltotop = makeScrollToAction(scrollToTop);
var scrolltobottom = makeScrollToAction(scrollToBottom);

// node_modules/focus-options-polyfill/index.js
(function() {
  if (typeof window === "undefined" || typeof document === "undefined" || typeof HTMLElement === "undefined") {
    return;
  }
  var supportsPreventScrollOption = false;
  try {
    var focusElem = document.createElement("div");
    focusElem.addEventListener(
      "focus",
      function(event2) {
        event2.preventDefault();
        event2.stopPropagation();
      },
      true
    );
    focusElem.focus(
      Object.defineProperty({}, "preventScroll", {
        get: function() {
          if (navigator && typeof navigator.userAgent !== "undefined" && navigator.userAgent && navigator.userAgent.match(/Edge\/1[7-8]/)) {
            return supportsPreventScrollOption = false;
          }
          supportsPreventScrollOption = true;
        }
      })
    );
  } catch (e) {
  }
  if (HTMLElement.prototype.nativeFocus === void 0 && !supportsPreventScrollOption) {
    HTMLElement.prototype.nativeFocus = HTMLElement.prototype.focus;
    var calcScrollableElements = function(element) {
      var parent = element.parentNode;
      var scrollableElements = [];
      var rootScrollingElement = document.scrollingElement || document.documentElement;
      while (parent && parent !== rootScrollingElement) {
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) {
          scrollableElements.push([
            parent,
            parent.scrollTop,
            parent.scrollLeft
          ]);
        }
        parent = parent.parentNode;
      }
      parent = rootScrollingElement;
      scrollableElements.push([parent, parent.scrollTop, parent.scrollLeft]);
      return scrollableElements;
    };
    var restoreScrollPosition = function(scrollableElements) {
      for (var i = 0; i < scrollableElements.length; i++) {
        scrollableElements[i][0].scrollTop = scrollableElements[i][1];
        scrollableElements[i][0].scrollLeft = scrollableElements[i][2];
      }
      scrollableElements = [];
    };
    var patchedFocus = function(args) {
      if (args && args.preventScroll) {
        var evScrollableElements = calcScrollableElements(this);
        if (typeof setTimeout === "function") {
          var thisElem = this;
          setTimeout(function() {
            thisElem.nativeFocus();
            restoreScrollPosition(evScrollableElements);
          }, 0);
        } else {
          this.nativeFocus();
          restoreScrollPosition(evScrollableElements);
        }
      } else {
        this.nativeFocus();
      }
    };
    HTMLElement.prototype.focus = patchedFocus;
  }
})();

// node_modules/svelte-parallax/src/Parallax.svelte
Parallax[FILENAME] = "node_modules/svelte-parallax/src/Parallax.svelte";
var root = add_locations(from_html(`<div><!></div>`), Parallax[FILENAME], [[119, 0]]);
var $$css = {
  hash: "s-AetvpQZB4ayQ",
  code: "\n  .parallax-container.s-AetvpQZB4ayQ {\n    position: relative;\n    overflow: hidden;\n    box-sizing: border-box;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFyYWxsYXguc3ZlbHRlIiwic291cmNlcyI6WyJQYXJhbGxheC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgaW1wb3J0IHsgc2V0Q29udGV4dCwgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IHNwcmluZyB9IGZyb20gJ3N2ZWx0ZS9tb3Rpb24nO1xuICBpbXBvcnQgeyB3cml0YWJsZSwgZGVyaXZlZCB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XG4gIGltcG9ydCB7IHF1YWRJbk91dCB9IGZyb20gJ3N2ZWx0ZS9lYXNpbmcnO1xuICBpbXBvcnQgeyB3cml0YWJsZVNldCwgY29udGV4dEtleSwgY2xhbXAgfSBmcm9tICcuL3V0aWxzJztcbiAgaW1wb3J0IHsgc2Nyb2xsVG8gYXMgc3ZlbHRlU2Nyb2xsVG8gfSBmcm9tICcuL3Njcm9sbC1mb3JrL3N2ZWx0ZVNjcm9sbFRvLmpzJztcbiAgaW1wb3J0ICdmb2N1cy1vcHRpb25zLXBvbHlmaWxsJztcblxuICAvLyBiaW5kOnRoaXNcbiAgbGV0IGNvbnRhaW5lcjtcbiAgLy8gYmluZDppbm5lckhlaWdodFxuICBsZXQgaW5uZXJIZWlnaHQ7XG5cbiAgLyoqIHRoZSBudW1iZXIgb2Ygc2VjdGlvbnMgdGhlIGNvbnRhaW5lciBzcGFucyAqL1xuICBleHBvcnQgbGV0IHNlY3Rpb25zID0gMTtcbiAgLyoqIHRoZSBoZWlnaHQgb2YgYSBzZWN0aW9uLCBkZWZhdWx0cyB0byB3aW5kb3cuaW5uZXJIZWlnaHQgKi9cbiAgZXhwb3J0IGxldCBzZWN0aW9uSGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAvKiogc3ByaW5nIGNvbmZpZyBvYmplY3QgKi9cbiAgZXhwb3J0IGxldCBjb25maWcgPSB7IHN0aWZmbmVzczogMC4wMTcsIGRhbXBpbmc6IDAuMjYgfTtcbiAgLyoqIHRocmVzaG9sZCBvZiBlZmZlY3Qgc3RhcnQvZW5kIHdoZW4gY29udGFpbmVyIGVudGVycy9leGl0cyB2aWV3cG9ydCAqL1xuICBleHBvcnQgbGV0IHRocmVzaG9sZCA9IHsgdG9wOiAxLCBib3R0b206IDEgfTtcbiAgLyoqIGEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIHByb2dyZXNzIG9iamVjdDogYHsgcHJvZ3Jlc3M6IGZsb2F0LCBzZWN0aW9uOiBudW1iZXIgfWAgKi9cbiAgZXhwb3J0IGxldCBvblByb2dyZXNzID0gdW5kZWZpbmVkO1xuICAvKiogYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIFwic2Nyb2xsVG9wXCIgLS0gdGhlIG51bWJlciBvZiBwaXhlbHMgc2Nyb2xsZWQgYmV0d2VlbiBlYWNoIHRocmVzaG9sZCAqL1xuICBleHBvcnQgbGV0IG9uU2Nyb2xsID0gdW5kZWZpbmVkO1xuICAvKiogZGlzYWJsZSBwYXJhbGxheCBlZmZlY3QsIGxheWVycyB3aWxsIGJlIGZyb3plbiBhdCB0YXJnZXQgcG9zaXRpb24gKi9cbiAgZXhwb3J0IGxldCBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGJpbmQ6c2Nyb2xsWVxuICBjb25zdCB5ID0gd3JpdGFibGUoMCk7XG4gIC8vIHRvcCBjb29yZCBvZiBQYXJhbGxheCBjb250YWluZXJcbiAgY29uc3QgdG9wID0gd3JpdGFibGUoMCk7XG4gIC8vIGhlaWdodCBvZiBhIHNlY3Rpb25cbiAgY29uc3QgaGVpZ2h0ID0gd3JpdGFibGUoMCk7XG4gIC8vIHNwcmluZyBzdG9yZSB0byBob2xkIHNjcm9sbCBwcm9ncmVzc1xuICBjb25zdCBwcm9ncmVzcyA9IHNwcmluZyh1bmRlZmluZWQsIHsgLi4uY29uZmlnLCBwcmVjaXNpb246IDAuMDAxIH0pO1xuXG4gIC8vIGZha2UgaW50ZXJzZWN0aW9uIG9ic2VydmVyXG4gIGNvbnN0IHNjcm9sbFRvcCA9IGRlcml2ZWQoW3ksIHRvcCwgaGVpZ2h0XSwgKFskeSwgJHRvcCwgJGhlaWdodF0sIHNldCkgPT4ge1xuICAgIGNvbnN0IGR5ID0gJHkgLSAkdG9wO1xuICAgIGNvbnN0IG1pbiA9IDAgLSAkaGVpZ2h0ICsgJGhlaWdodCAqIHRocmVzaG9sZC50b3A7XG4gICAgY29uc3QgbWF4ID0gJGhlaWdodCAqIHNlY3Rpb25zIC0gJGhlaWdodCAqIHRocmVzaG9sZC5ib3R0b207XG4gICAgY29uc3Qgc3RlcCA9IGNsYW1wKGR5LCBtaW4sIG1heCk7XG4gICAgc2V0KHN0ZXApO1xuICB9KTtcblxuICAkOiBpZiAob25TY3JvbGwpIG9uU2Nyb2xsKCRzY3JvbGxUb3ApO1xuICAkOiBpZiAob25Qcm9ncmVzcykgc2V0UHJvZ3Jlc3MoJHNjcm9sbFRvcCwgJGhlaWdodCk7XG4gICQ6IGlmIChvblByb2dyZXNzKSBvblByb2dyZXNzKCRwcm9ncmVzcyA/PyAwKTtcblxuICBjb25zdCBzZXRQcm9ncmVzcyA9IChzY3JvbGxUb3AsIGhlaWdodCkgPT4ge1xuICAgIGlmIChoZWlnaHQgPT09IDApIHtcbiAgICAgIHByb2dyZXNzLnNldCgwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gaGVpZ2h0ICogc2VjdGlvbnMgLSBoZWlnaHQ7XG4gICAgcHJvZ3Jlc3Muc2V0KGNsYW1wKHNjcm9sbFRvcCAvIHNjcm9sbEhlaWdodCwgMCwgMSkpO1xuICB9O1xuXG4gIC8vIGV2ZW50dWFsbHkgZmlsbGVkIHdpdGggUGFyYWxsYXhMYXllciBvYmplY3RzXG4gIGNvbnN0IGxheWVycyA9IHdyaXRhYmxlU2V0KG5ldyBTZXQoKSk7XG4gIC8vIHVwZGF0ZSBQYXJhbGxheExheWVycyBmcm9tIHBhcmVudFxuICAkOiAkbGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgbGF5ZXIuc2V0SGVpZ2h0KCRoZWlnaHQpO1xuICB9KTtcbiAgJDogJGxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgIGxheWVyLnNldFBvc2l0aW9uKCRzY3JvbGxUb3AsICRoZWlnaHQsIGRpc2FibGVkKTtcbiAgfSk7XG4gICQ6IGlmICgkaGVpZ2h0ICE9PSAwKSAoc2VjdGlvbkhlaWdodCwgc2V0RGltZW5zaW9ucygpKTtcblxuICBzZXRDb250ZXh0KGNvbnRleHRLZXksIHtcbiAgICBjb25maWcsXG4gICAgYWRkTGF5ZXI6IChsYXllcikgPT4ge1xuICAgICAgbGF5ZXJzLmFkZChsYXllcik7XG4gICAgfSxcbiAgICByZW1vdmVMYXllcjogKGxheWVyKSA9PiB7XG4gICAgICBsYXllcnMuZGVsZXRlKGxheWVyKTtcbiAgICB9LFxuICB9KTtcblxuICBvbk1vdW50KCgpID0+IHtcbiAgICBzZXREaW1lbnNpb25zKCk7XG4gIH0pO1xuXG4gIGNvbnN0IHNldERpbWVuc2lvbnMgPSAoKSA9PiB7XG4gICAgaGVpZ2h0LnNldChzZWN0aW9uSGVpZ2h0ID8gc2VjdGlvbkhlaWdodCA6IGlubmVySGVpZ2h0KTtcbiAgICB0b3Auc2V0KGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQpO1xuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbFRvKHNlY3Rpb24sIHsgc2VsZWN0b3IgPSAnJywgZHVyYXRpb24gPSA1MDAsIGVhc2luZyA9IHF1YWRJbk91dCB9ID0ge30pIHtcbiAgICBjb25zdCBzY3JvbGxUYXJnZXQgPSAkdG9wICsgJGhlaWdodCAqIChzZWN0aW9uIC0gMSk7XG5cbiAgICBjb25zdCBmb2N1c1RhcmdldCA9ICgpID0+IHtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIC8vIGRvbid0IGFuaW1hdGUgc2Nyb2xsIGlmIGRpc2FibGVkXG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oeyB0b3A6IHNjcm9sbFRhcmdldCB9KTtcbiAgICAgIHNlbGVjdG9yICYmIGZvY3VzVGFyZ2V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3ZlbHRlU2Nyb2xsVG8oe1xuICAgICAgeTogc2Nyb2xsVGFyZ2V0LFxuICAgICAgZHVyYXRpb24sXG4gICAgICBlYXNpbmcsXG4gICAgICBvbkRvbmU6IHNlbGVjdG9yID8gZm9jdXNUYXJnZXQgOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6d2luZG93XG4gIGJpbmQ6c2Nyb2xsWT17JHl9XG4gIGJpbmQ6aW5uZXJIZWlnaHRcbiAgb246cmVzaXplPXsoKSA9PiBzZXRUaW1lb3V0KHNldERpbWVuc2lvbnMsIDApfVxuLz5cblxuPGRpdlxuICB7Li4uJCRyZXN0UHJvcHN9XG4gIGNsYXNzPVwicGFyYWxsYXgtY29udGFpbmVyIHskJHJlc3RQcm9wcy5jbGFzcyA/ICQkcmVzdFByb3BzLmNsYXNzIDogJyd9XCJcbiAgc3R5bGU9XCJcbiAgICBoZWlnaHQ6IHskaGVpZ2h0ICogc2VjdGlvbnN9cHg7XG4gICAgeyQkcmVzdFByb3BzLnN0eWxlID8gJCRyZXN0UHJvcHMuc3R5bGUgOiAnJ307XG4gIFwiXG4gIGJpbmQ6dGhpcz17Y29udGFpbmVyfVxuPlxuICA8c2xvdCAvPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgLnBhcmFsbGF4LWNvbnRhaW5lciB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function Parallax($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "scrollTo",
    "sections",
    "sectionHeight",
    "config",
    "threshold",
    "onProgress",
    "onScroll",
    "disabled"
  ]);
  push($$props, false, Parallax);
  append_styles($$anchor, $$css);
  const [$$stores, $$cleanup] = setup_stores();
  const $scrollTop = () => (validate_store(scrollTop, "scrollTop"), store_get(scrollTop, "$scrollTop", $$stores));
  const $height = () => (validate_store(height, "height"), store_get(height, "$height", $$stores));
  const $progress = () => (validate_store(progress, "progress"), store_get(progress, "$progress", $$stores));
  const $layers = () => (validate_store(layers, "layers"), store_get(layers, "$layers", $$stores));
  const $top = () => (validate_store(top, "top"), store_get(top, "$top", $$stores));
  const $y = () => (validate_store(y, "y"), store_get(y, "$y", $$stores));
  let container = mutable_source();
  let innerHeight = mutable_source();
  let sections = prop($$props, "sections", 8, 1);
  let sectionHeight = prop($$props, "sectionHeight", 8, void 0);
  let config = prop($$props, "config", 24, () => ({ stiffness: 0.017, damping: 0.26 }));
  let threshold = prop($$props, "threshold", 24, () => ({ top: 1, bottom: 1 }));
  let onProgress = prop($$props, "onProgress", 8, void 0);
  let onScroll = prop($$props, "onScroll", 8, void 0);
  let disabled = prop($$props, "disabled", 8, false);
  const y = writable(0);
  const top = writable(0);
  const height = writable(0);
  const progress = spring(void 0, { ...config(), precision: 1e-3 });
  const scrollTop = derived([y, top, height], ([$y2, $top2, $height2], set2) => {
    const dy = $y2 - $top2;
    const min = 0 - $height2 + $height2 * threshold().top;
    const max = $height2 * sections() - $height2 * threshold().bottom;
    const step = clamp(dy, min, max);
    set2(step);
  });
  const setProgress = (scrollTop2, height2) => {
    if (strict_equals(height2, 0)) {
      progress.set(0);
      return;
    }
    const scrollHeight = height2 * sections() - height2;
    progress.set(clamp(scrollTop2 / scrollHeight, 0, 1));
  };
  const layers = writableSet(/* @__PURE__ */ new Set());
  setContext(contextKey, {
    config: config(),
    addLayer: (layer) => {
      layers.add(layer);
    },
    removeLayer: (layer) => {
      layers.delete(layer);
    }
  });
  onMount(() => {
    setDimensions();
  });
  const setDimensions = () => {
    height.set(sectionHeight() ? sectionHeight() : get(innerHeight));
    top.set(get(container).getBoundingClientRect().top + window.pageYOffset);
  };
  function scrollTo2(section, { selector = "", duration = 500, easing = quadInOut } = {}) {
    const scrollTarget = $top() + $height() * (section - 1);
    const focusTarget = () => {
      document.querySelector(selector).focus({ preventScroll: true });
    };
    if (disabled()) {
      window.scrollTo({ top: scrollTarget });
      selector && focusTarget();
      return;
    }
    scrollTo({
      y: scrollTarget,
      duration,
      easing,
      onDone: selector ? focusTarget : () => {
      }
    });
  }
  legacy_pre_effect(() => (deep_read_state(onScroll()), $scrollTop()), () => {
    if (onScroll()) onScroll()($scrollTop());
  });
  legacy_pre_effect(() => (deep_read_state(onProgress()), $scrollTop(), $height()), () => {
    if (onProgress()) setProgress($scrollTop(), $height());
  });
  legacy_pre_effect(() => (deep_read_state(onProgress()), $progress()), () => {
    if (onProgress()) onProgress()($progress() ?? 0);
  });
  legacy_pre_effect(() => ($layers(), $height()), () => {
    $layers().forEach((layer) => {
      layer.setHeight($height());
    });
  });
  legacy_pre_effect(
    () => ($layers(), $scrollTop(), $height(), deep_read_state(disabled())),
    () => {
      $layers().forEach((layer) => {
        layer.setPosition($scrollTop(), $height(), disabled());
      });
    }
  );
  legacy_pre_effect(() => ($height(), deep_read_state(sectionHeight())), () => {
    if (strict_equals($height(), 0, false)) sectionHeight(), setDimensions();
  });
  legacy_pre_effect_reset();
  init();
  var div = root();
  event("resize", $window, () => setTimeout(setDimensions, 0));
  attribute_effect(
    div,
    () => ({
      ...$$restProps,
      class: `parallax-container ${(deep_read_state($$restProps), untrack(() => $$restProps.class ? $$restProps.class : "")) ?? ""}`,
      style: `
    height: ${$height() * sections()}px;
    ${(deep_read_state($$restProps), untrack(() => $$restProps.style ? $$restProps.style : "")) ?? ""};
  `
    }),
    void 0,
    void 0,
    "s-AetvpQZB4ayQ"
  );
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  bind_this(div, ($$value) => set(container, $$value), () => get(container));
  bind_window_scroll("y", $y, ($$value) => store_set(y, $$value));
  bind_window_size("innerHeight", ($$value) => set(innerHeight, $$value));
  append($$anchor, div);
  bind_prop($$props, "scrollTo", scrollTo2);
  var $$pop = pop({
    get scrollTo() {
      return scrollTo2;
    },
    ...legacy_api()
  });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Parallax = hmr(Parallax, () => Parallax[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-AetvpQZB4ayQ");
    module.default[HMR].source = Parallax[HMR].source;
    set(Parallax[HMR].source, module.default[HMR].original);
  });
}
var Parallax_default = Parallax;

// node_modules/svelte-parallax/src/ParallaxLayer.svelte
ParallaxLayer[FILENAME] = "node_modules/svelte-parallax/src/ParallaxLayer.svelte";
var root2 = add_locations(from_html(`<div><!></div>`), ParallaxLayer[FILENAME], [[69, 0]]);
var $$css2 = {
  hash: "s-WE5eftVD1ZAe",
  code: "\n  .parallax-layer.s-WE5eftVD1ZAe {\n    width: 100%;\n    position: absolute;\n    box-sizing: border-box;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFyYWxsYXhMYXllci5zdmVsdGUiLCJzb3VyY2VzIjpbIlBhcmFsbGF4TGF5ZXIuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGdldENvbnRleHQsIG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgeyBzcHJpbmcgfSBmcm9tICdzdmVsdGUvbW90aW9uJztcbiAgaW1wb3J0IHsgY29udGV4dEtleSwgY2xhbXAgfSBmcm9tICcuL3V0aWxzJztcblxuICAvKiogcmF0ZSB0aGF0IHRoZSBsYXllciBzY3JvbGxzIHJlbGF0aXZlIHRvIGBzY3JvbGxZYCAqL1xuICBleHBvcnQgbGV0IHJhdGUgPSAwLjU7XG4gIC8qKiBvZmZzZXQgZnJvbSB0b3Agb2YgY29udGFpbmVyIHdoZW4gbGF5ZXIgaXMgaW4gdmlld3BvcnQgKi9cbiAgZXhwb3J0IGxldCBvZmZzZXQgPSAwO1xuICAvKiogaG93IG1hbnkgc2VjdGlvbnMgdGhlIGxheWVyIHNwYW5zICovXG4gIGV4cG9ydCBsZXQgc3BhbiA9IDE7XG4gIC8qKiBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLCByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIG9mIHRoZSBsYXllciAqL1xuICBleHBvcnQgbGV0IG9uUHJvZ3Jlc3MgPSB1bmRlZmluZWQ7XG5cbiAgLy8gZ2V0IGNvbnRleHQgZnJvbSBQYXJhbGxheFxuICBjb25zdCB7IGNvbmZpZywgYWRkTGF5ZXIsIHJlbW92ZUxheWVyIH0gPSBnZXRDb250ZXh0KGNvbnRleHRLZXkpO1xuXG4gIC8vIHNwcmluZyBzdG9yZSB0byBob2xkIGNoYW5naW5nIHNjcm9sbCBjb29yZGluYXRlXG4gIGNvbnN0IGNvb3JkID0gc3ByaW5nKHVuZGVmaW5lZCwgY29uZmlnKTtcbiAgLy8gYW5kIG9uZSB0byBob2xkIGludGVyc2VjdGluZyBwcm9ncmVzc1xuICBjb25zdCBwcm9ncmVzcyA9IHNwcmluZyh1bmRlZmluZWQsIHsgLi4uY29uZmlnLCBwcmVjaXNpb246IDAuMDAxIH0pO1xuICAvLyBsYXllciBoZWlnaHRcbiAgbGV0IGhlaWdodDtcblxuICBjb25zdCBsYXllciA9IHtcbiAgICBzZXRQb3NpdGlvbjogKHNjcm9sbFRvcCwgc2VjdGlvbkhlaWdodCwgZGlzYWJsZWQpID0+IHtcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICBjb29yZC5zZXQob2Zmc2V0ICogc2VjdGlvbkhlaWdodCwgeyBoYXJkOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBhbW91bnQgdG8gc2Nyb2xsIGJlZm9yZSBsYXllciBpcyBhdCB0YXJnZXQgcG9zaXRpb25cbiAgICAgIGNvbnN0IHRhcmdldFNjcm9sbCA9IE1hdGguZmxvb3Iob2Zmc2V0KSAqIHNlY3Rpb25IZWlnaHQ7XG4gICAgICAvLyBkaXN0YW5jZSB0byB0YXJnZXQgcG9zaXRpb25cbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gb2Zmc2V0ICogc2VjdGlvbkhlaWdodCArIHRhcmdldFNjcm9sbCAqIHJhdGU7XG4gICAgICBjb29yZC5zZXQoLShzY3JvbGxUb3AgKiByYXRlKSArIGRpc3RhbmNlKTtcbiAgICAgIHByb2dyZXNzLnNldChnZXRQcm9ncmVzcyhzY3JvbGxUb3AsIHJhdGUsIGRpc3RhbmNlLCBzZWN0aW9uSGVpZ2h0KSk7XG4gICAgfSxcbiAgICBzZXRIZWlnaHQ6IChzZWN0aW9uSGVpZ2h0KSA9PiB7XG4gICAgICBoZWlnaHQgPSBzcGFuICogc2VjdGlvbkhlaWdodDtcbiAgICB9LFxuICB9O1xuXG4gIGNvbnN0IGdldFByb2dyZXNzID0gKHNjcm9sbFRvcCwgcmF0ZSwgZGlzdGFuY2UsIHNlY3Rpb25IZWlnaHQpID0+IHtcbiAgICBjb25zdCBhcHBhcmVudFJhdGUgPSByYXRlICsgMTtcbiAgICBjb25zdCBoYWxmV2F5ID0gZGlzdGFuY2UgLyBhcHBhcmVudFJhdGU7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gcmF0ZSA+PSAwID8gMSA6IC0xO1xuICAgIGNvbnN0IHNjcm9sbERpc3RhbmNlID0gKHNlY3Rpb25IZWlnaHQgLyBhcHBhcmVudFJhdGUpICogZGlyZWN0aW9uO1xuICAgIGNvbnN0IHN0YXJ0ID0gaGFsZldheSAtIHNjcm9sbERpc3RhbmNlO1xuICAgIGNvbnN0IGVuZCA9IGhhbGZXYXkgKyBzY3JvbGxEaXN0YW5jZSAqIHNwYW47XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSAoc2Nyb2xsVG9wIC0gc3RhcnQpIC8gKGVuZCAtIHN0YXJ0KTtcbiAgICByZXR1cm4gY2xhbXAocHJvZ3Jlc3MsIDAsIDEpO1xuICB9O1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIC8vIHJlZ2lzdGVyIGxheWVyIHdpdGggcGFyZW50XG4gICAgYWRkTGF5ZXIobGF5ZXIpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIGNsZWFuIHVwXG4gICAgICByZW1vdmVMYXllcihsYXllcik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gdHJhbnNsYXRlIGxheWVyIGFjY29yZGluZyB0byBjb29yZGluYXRlXG4gICQ6IHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUzZCgwcHgsICR7JGNvb3JkfXB4LCAwcHgpO2A7XG4gICQ6IGlmIChvblByb2dyZXNzKSBvblByb2dyZXNzKCRwcm9ncmVzcyA/PyAwKTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gIHsuLi4kJHJlc3RQcm9wc31cbiAgY2xhc3M9XCJwYXJhbGxheC1sYXllciB7JCRyZXN0UHJvcHMuY2xhc3MgPyAkJHJlc3RQcm9wcy5jbGFzcyA6ICcnfVwiXG4gIHN0eWxlPVwiXG4gICAgeyQkcmVzdFByb3BzLnN0eWxlID8gJCRyZXN0UHJvcHMuc3R5bGUgOiAnJ307XG4gICAgaGVpZ2h0OiB7aGVpZ2h0fXB4O1xuICAgIC1tcy10cmFuc2Zvcm06IHt0cmFuc2xhdGV9O1xuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB7dHJhbnNsYXRlfTtcbiAgICB0cmFuc2Zvcm06IHt0cmFuc2xhdGV9O1xuICBcIlxuPlxuICA8c2xvdCBwcm9ncmVzcz17JHByb2dyZXNzfSAvPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgLnBhcmFsbGF4LWxheWVyIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function ParallaxLayer($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["rate", "offset", "span", "onProgress"]);
  push($$props, false, ParallaxLayer);
  append_styles($$anchor, $$css2);
  const [$$stores, $$cleanup] = setup_stores();
  const $coord = () => (validate_store(coord, "coord"), store_get(coord, "$coord", $$stores));
  const $progress = () => (validate_store(progress, "progress"), store_get(progress, "$progress", $$stores));
  const translate = mutable_source();
  let rate = prop($$props, "rate", 8, 0.5);
  let offset = prop($$props, "offset", 8, 0);
  let span = prop($$props, "span", 8, 1);
  let onProgress = prop($$props, "onProgress", 8, void 0);
  const { config, addLayer, removeLayer } = getContext(contextKey);
  const coord = spring(void 0, config);
  const progress = spring(void 0, { ...config, precision: 1e-3 });
  let height = mutable_source();
  const layer = {
    setPosition: (scrollTop, sectionHeight, disabled) => {
      if (disabled) {
        coord.set(offset() * sectionHeight, { hard: true });
        return;
      }
      const targetScroll = Math.floor(offset()) * sectionHeight;
      const distance = offset() * sectionHeight + targetScroll * rate();
      coord.set(-(scrollTop * rate()) + distance);
      progress.set(getProgress(scrollTop, rate(), distance, sectionHeight));
    },
    setHeight: (sectionHeight) => {
      set(height, span() * sectionHeight);
    }
  };
  const getProgress = (scrollTop, rate2, distance, sectionHeight) => {
    const apparentRate = rate2 + 1;
    const halfWay = distance / apparentRate;
    const direction = rate2 >= 0 ? 1 : -1;
    const scrollDistance = sectionHeight / apparentRate * direction;
    const start = halfWay - scrollDistance;
    const end = halfWay + scrollDistance * span();
    const progress2 = (scrollTop - start) / (end - start);
    return clamp(progress2, 0, 1);
  };
  onMount(() => {
    addLayer(layer);
    return () => {
      removeLayer(layer);
    };
  });
  legacy_pre_effect(() => $coord(), () => {
    set(translate, `translate3d(0px, ${$coord()}px, 0px);`);
  });
  legacy_pre_effect(() => (deep_read_state(onProgress()), $progress()), () => {
    if (onProgress()) onProgress()($progress() ?? 0);
  });
  legacy_pre_effect_reset();
  init();
  var div = root2();
  attribute_effect(
    div,
    () => ({
      ...$$restProps,
      class: `parallax-layer ${(deep_read_state($$restProps), untrack(() => $$restProps.class ? $$restProps.class : "")) ?? ""}`,
      style: `
    ${(deep_read_state($$restProps), untrack(() => $$restProps.style ? $$restProps.style : "")) ?? ""};
    height: ${get(height) ?? ""}px;
    -ms-transform: ${get(translate) ?? ""};
    -webkit-transform: ${get(translate) ?? ""};
    transform: ${get(translate) ?? ""};
  `
    }),
    void 0,
    void 0,
    "s-WE5eftVD1ZAe"
  );
  var node = child(div);
  slot(
    node,
    $$props,
    "default",
    {
      get progress() {
        return $progress();
      }
    },
    null
  );
  reset(div);
  append($$anchor, div);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  ParallaxLayer = hmr(ParallaxLayer, () => ParallaxLayer[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-WE5eftVD1ZAe");
    module.default[HMR].source = ParallaxLayer[HMR].source;
    set(ParallaxLayer[HMR].source, module.default[HMR].original);
  });
}
var ParallaxLayer_default = ParallaxLayer;

// node_modules/svelte-parallax/src/StickyLayer.svelte
StickyLayer[FILENAME] = "node_modules/svelte-parallax/src/StickyLayer.svelte";
var root3 = add_locations(from_html(`<div><!></div>`), StickyLayer[FILENAME], [[70, 0]]);
var $$css3 = {
  hash: "s-xL-aMYCKM7Kd",
  code: "\n  .sticky-layer.s-xL-aMYCKM7Kd {\n    width: 100%;\n    top: 0;\n    left: 0;\n    box-sizing: border-box;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RpY2t5TGF5ZXIuc3ZlbHRlIiwic291cmNlcyI6WyJTdGlja3lMYXllci5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0Q29udGV4dCwgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IHNwcmluZyB9IGZyb20gJ3N2ZWx0ZS9tb3Rpb24nO1xuICBpbXBvcnQgeyBjb250ZXh0S2V5LCBjbGFtcCB9IGZyb20gJy4vdXRpbHMnO1xuXG4gIC8vIG9mZnNldCBib3VuZHMgd2hlcmUgbGF5ZXIgaXMgc3RpY2t5XG4gIGV4cG9ydCBsZXQgb2Zmc2V0ID0geyB0b3A6IDAsIGJvdHRvbTogMCB9O1xuICAvLyBleHBvc2UgcHJvZ3Jlc3Mgc3RvcmVcbiAgZXhwb3J0IGxldCBvblByb2dyZXNzID0gdW5kZWZpbmVkO1xuXG4gIC8vIGdldCBjb250ZXh0IGZyb20gUGFyYWxsYXhcbiAgY29uc3QgeyBjb25maWcsIGFkZExheWVyLCByZW1vdmVMYXllciB9ID0gZ2V0Q29udGV4dChjb250ZXh0S2V5KTtcblxuICAvLyBpZiBsYXllciBzaG91bGQgc3RpY2tcbiAgbGV0IGlzU3RpY2t5ID0gZmFsc2U7XG4gIC8vIHRvcCBjb29yZGluYXRlIG9mIGxheWVyXG4gIGxldCBjb29yZCA9IDA7XG4gIC8vIGxheWVyIGhlaWdodFxuICBsZXQgaGVpZ2h0O1xuICAvLyBzcHJpbmcgc3RvcmUgdG8gaG9sZCBwcm9ncmVzcyB2YWx1ZVxuICBjb25zdCBwcm9ncmVzcyA9IHNwcmluZygwLCB7IC4uLmNvbmZpZywgcHJlY2lzaW9uOiAwLjAwMSB9KTtcblxuICBjb25zdCBsYXllciA9IHtcbiAgICBzZXRQb3NpdGlvbjogKHNjcm9sbFRvcCwgc2VjdGlvbkhlaWdodCwgZGlzYWJsZWQpID0+IHtcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICBpc1N0aWNreSA9IGZhbHNlO1xuICAgICAgICBjb29yZCA9IHNlY3Rpb25IZWlnaHQgKiBvZmZzZXQudG9wO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gc2VjdGlvbkhlaWdodCAqIG9mZnNldC50b3A7XG4gICAgICBjb25zdCBlbmQgPSBzZWN0aW9uSGVpZ2h0ICogKG9mZnNldC5ib3R0b20gfHwgb2Zmc2V0LnRvcCArIDEpO1xuICAgICAgaXNTdGlja3kgPSBnZXRTdGlja3koc2Nyb2xsVG9wLCBzdGFydCwgZW5kKTtcbiAgICAgIGNvb3JkID0gZ2V0Q29vcmQoc2Nyb2xsVG9wLCBzdGFydCwgZW5kLCBpc1N0aWNreSk7XG4gICAgICBwcm9ncmVzcy5zZXQoY2xhbXAoKHNjcm9sbFRvcCAtIHN0YXJ0KSAvIChlbmQgLSBzdGFydCksIDAsIDEpKTtcbiAgICB9LFxuICAgIHNldEhlaWdodDogKHNlY3Rpb25IZWlnaHQpID0+IHtcbiAgICAgIGhlaWdodCA9IHNlY3Rpb25IZWlnaHQ7XG4gICAgfSxcbiAgfTtcblxuICBjb25zdCBnZXRTdGlja3kgPSAoc2Nyb2xsVG9wLCBzdGFydCwgZW5kKSA9PiB7XG4gICAgLy8gY292ZXJzIGFuIGVkZ2UgY2FzZSB3aGVyZSBvZmZzZXQudG9wID09PSAwXG4gICAgLy8gYW5kIHRoZXJlIGFyZSBvdGhlciBlbGVtZW50cyBpbiB0aGUgRE9NIGJlZm9yZVxuICAgIC8vIHRoZSBQYXJhbGxheCBjb250YWluZXJcbiAgICBjb25zdCBzdGFydENvbmRpdGlvbiA9IHN0YXJ0ID09PSAwID8gc2Nyb2xsVG9wID4gc3RhcnQgOiBzY3JvbGxUb3AgPj0gc3RhcnQ7XG4gICAgcmV0dXJuIHN0YXJ0Q29uZGl0aW9uICYmIHNjcm9sbFRvcCA8PSBlbmQ7XG4gIH07XG5cbiAgY29uc3QgZ2V0Q29vcmQgPSAoc2Nyb2xsVG9wLCBzdGFydCwgZW5kLCBpc1N0aWNreSkgPT4ge1xuICAgIGlmIChpc1N0aWNreSkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHNjcm9sbFRvcCA8PSBzdGFydCA/IHN0YXJ0IDogZW5kO1xuICB9O1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIC8vIHJlZ2lzdGVyIGxheWVyIHdpdGggcGFyZW50XG4gICAgYWRkTGF5ZXIobGF5ZXIpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vY2xlYW4gdXBcbiAgICAgIHJlbW92ZUxheWVyKGxheWVyKTtcbiAgICB9O1xuICB9KTtcblxuICAkOiBwb3NpdGlvbiA9IGlzU3RpY2t5ID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG4gICQ6IHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUzZCgwcHgsICR7Y29vcmR9cHgsIDBweCk7YDtcbiAgJDogaWYgKG9uUHJvZ3Jlc3MpIG9uUHJvZ3Jlc3MoJHByb2dyZXNzID8/IDApO1xuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgey4uLiQkcmVzdFByb3BzfVxuICBjbGFzcz1cInN0aWNreS1sYXllciB7JCRyZXN0UHJvcHMuY2xhc3MgPyAkJHJlc3RQcm9wcy5jbGFzcyA6ICcnfVwiXG4gIHN0eWxlPVwiXG4gICAgeyQkcmVzdFByb3BzLnN0eWxlID8gJCRyZXN0UHJvcHMuc3R5bGUgOiAnJ307XG4gICAgcG9zaXRpb246IHtwb3NpdGlvbn07XG4gICAgaGVpZ2h0OiB7aGVpZ2h0fXB4O1xuICAgIC1tcy10cmFuc2Zvcm06IHt0cmFuc2xhdGV9XG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHt0cmFuc2xhdGV9XG4gICAgdHJhbnNmb3JtOiB7dHJhbnNsYXRlfVxuICBcIlxuPlxuICA8c2xvdCBwcm9ncmVzcz17JHByb2dyZXNzfSAvPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgLnN0aWNreS1sYXllciB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function StickyLayer($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, ["children", "$$slots", "$$events", "$$legacy"]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["offset", "onProgress"]);
  push($$props, false, StickyLayer);
  append_styles($$anchor, $$css3);
  const [$$stores, $$cleanup] = setup_stores();
  const $progress = () => (validate_store(progress, "progress"), store_get(progress, "$progress", $$stores));
  const position = mutable_source();
  const translate = mutable_source();
  let offset = prop($$props, "offset", 24, () => ({ top: 0, bottom: 0 }));
  let onProgress = prop($$props, "onProgress", 8, void 0);
  const { config, addLayer, removeLayer } = getContext(contextKey);
  let isSticky = mutable_source(false);
  let coord = mutable_source(0);
  let height = mutable_source();
  const progress = spring(0, { ...config, precision: 1e-3 });
  const layer = {
    setPosition: (scrollTop, sectionHeight, disabled) => {
      if (disabled) {
        set(isSticky, false);
        set(coord, sectionHeight * offset().top);
        return;
      }
      const start = sectionHeight * offset().top;
      const end = sectionHeight * (offset().bottom || offset().top + 1);
      set(isSticky, getSticky(scrollTop, start, end));
      set(coord, getCoord(scrollTop, start, end, get(isSticky)));
      progress.set(clamp((scrollTop - start) / (end - start), 0, 1));
    },
    setHeight: (sectionHeight) => {
      set(height, sectionHeight);
    }
  };
  const getSticky = (scrollTop, start, end) => {
    const startCondition = strict_equals(start, 0) ? scrollTop > start : scrollTop >= start;
    return startCondition && scrollTop <= end;
  };
  const getCoord = (scrollTop, start, end, isSticky2) => {
    if (isSticky2) return 0;
    return scrollTop <= start ? start : end;
  };
  onMount(() => {
    addLayer(layer);
    return () => {
      removeLayer(layer);
    };
  });
  legacy_pre_effect(() => get(isSticky), () => {
    set(position, get(isSticky) ? "fixed" : "absolute");
  });
  legacy_pre_effect(() => get(coord), () => {
    set(translate, `translate3d(0px, ${get(coord)}px, 0px);`);
  });
  legacy_pre_effect(() => (deep_read_state(onProgress()), $progress()), () => {
    if (onProgress()) onProgress()($progress() ?? 0);
  });
  legacy_pre_effect_reset();
  init();
  var div = root3();
  attribute_effect(
    div,
    () => ({
      ...$$restProps,
      class: `sticky-layer ${(deep_read_state($$restProps), untrack(() => $$restProps.class ? $$restProps.class : "")) ?? ""}`,
      style: `
    ${(deep_read_state($$restProps), untrack(() => $$restProps.style ? $$restProps.style : "")) ?? ""};
    position: ${get(position) ?? ""};
    height: ${get(height) ?? ""}px;
    -ms-transform: ${get(translate) ?? ""}
    -webkit-transform: ${get(translate) ?? ""}
    transform: ${get(translate) ?? ""}
  `
    }),
    void 0,
    void 0,
    "s-xL-aMYCKM7Kd"
  );
  var node = child(div);
  slot(
    node,
    $$props,
    "default",
    {
      get progress() {
        return $progress();
      }
    },
    null
  );
  reset(div);
  append($$anchor, div);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  StickyLayer = hmr(StickyLayer, () => StickyLayer[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-xL-aMYCKM7Kd");
    module.default[HMR].source = StickyLayer[HMR].source;
    set(StickyLayer[HMR].source, module.default[HMR].original);
  });
}
var StickyLayer_default = StickyLayer;
export {
  Parallax_default as Parallax,
  ParallaxLayer_default as ParallaxLayer,
  StickyLayer_default as StickyLayer
};
//# sourceMappingURL=svelte-parallax.js.map
