import "./chunk-SZ3X4LJ7.js";
import {
  cubicInOut
} from "./chunk-YERFD2CZ.js";
import {
  get,
  writable
} from "./chunk-2DUUHTHR.js";
import "./chunk-U7P2NEEE.js";
import "./chunk-QSMT42QS.js";
import "./chunk-PPMGFJ2N.js";
import "./chunk-L3IDHH4W.js";
import "./chunk-K63UQA3V.js";
import "./chunk-UGBVNEQM.js";

// node_modules/svelte-scrolling/dist/store/index.js
var elements = writable([]);
var globalOptions = writable({
  offset: 0,
  duration: 500,
  passive: false,
  easing: cubicInOut,
  onStart: () => {
  },
  onDone: () => {
  }
});

// node_modules/svelte-scrolling/dist/internal/globalOptions.js
var globalOpts = get(globalOptions);
var getGlobalOptions = () => {
  return globalOpts;
};
var mergeGlobalOptions = (options) => {
  return Object.assign({}, globalOpts, options);
};
var setGlobalOptions = (options) => {
  globalOptions.update(() => Object.assign(globalOpts, options));
};
var globalOptions_default = setGlobalOptions;

// node_modules/svelte-scrolling/dist/shared/utils.js
var sanitize = (hash) => {
  return hash.replace(/[^A-Z0-9]/gi, "").toLowerCase();
};
var getElement = (elementsList2, reference) => {
  const element = elementsList2.find((el) => {
    return el.reference === reference;
  });
  if (!element) {
    return document.getElementById(reference);
  }
  return element.node;
};
var getPosition = (element) => {
  return { y: element.offsetTop, x: element.offsetLeft };
};

// node_modules/svelte-scrolling/dist/shared/smoothScroll.js
var currentPosition = (start, end, elapsed, duration, easing) => {
  if (elapsed > duration)
    return end;
  return start + (end - start) * easing(elapsed / duration);
};
var smoothScroll = async (options, callback) => {
  return new Promise((resolve) => {
    const { start, end, duration, easing } = options;
    const clock = Date.now();
    let step = () => {
      const elapsed = Date.now() - clock;
      const positionX = currentPosition(start.x, end.x, elapsed, duration, easing);
      const positionY = currentPosition(start.y, end.y, elapsed, duration, easing);
      callback({ x: positionX, y: positionY });
      if (elapsed > duration)
        return resolve();
      window.requestAnimationFrame(step);
    };
    window.addEventListener("wheel", function stopAnimation() {
      step = () => {
      };
      window.removeEventListener("wheel", stopAnimation);
    });
    window.requestAnimationFrame(step);
  });
};
var smoothScroll_default = smoothScroll;

// node_modules/svelte-scrolling/dist/shared/scrolling.js
var scrolling = async (coord, options) => {
  const { duration, easing, offset } = options;
  const startY = window.pageYOffset;
  const startX = window.pageXOffset;
  const endX = coord.x + offset;
  const endY = coord.y + offset;
  await smoothScroll_default({
    start: {
      x: startX,
      y: startY
    },
    end: {
      x: endX,
      y: endY
    },
    duration,
    easing
  }, (coord2) => {
    window.scroll(coord2.x, coord2.y);
  });
};
var scrolling_default = scrolling;

// node_modules/svelte-scrolling/dist/actions/ScrollTo.js
var elementsList = get(elements);
var handle = async (event, options) => {
  if (!options.passive)
    event.preventDefault();
  const { ref, onDone, onStart } = options;
  const duration = options.duration;
  const offset = options.offset;
  const easing = options.easing;
  const element = getElement(elementsList, ref);
  if (!element) {
    throw new Error(`Element reference '${ref}' not found`);
  }
  const endPosition = getPosition(element);
  onStart === null || onStart === void 0 ? void 0 : onStart({ element, offset, duration, endPosition });
  await scrolling_default(endPosition, { duration, offset, easing });
  onDone === null || onDone === void 0 ? void 0 : onDone({ element, offset, duration, endPosition });
};
var scrollTo = (node, options) => {
  if (!options) {
    throw new Error("scrollTo require a options");
  }
  let opts = Object.assign({ ref: "" }, getGlobalOptions());
  typeof options === "string" ? opts.ref = options : opts = Object.assign(opts, options);
  opts.ref = sanitize(opts.ref);
  if (!opts.ref) {
    throw new Error("scrollTo require a reference");
  }
  if (node instanceof HTMLAnchorElement) {
    node.href = `#${opts.ref}`;
  }
  if (node instanceof HTMLAnchorElement === false) {
    node.style.cursor = "pointer";
  }
  const _handler = (event) => handle(event, opts);
  node.addEventListener("click", _handler, { passive: opts.passive });
  node.addEventListener("touchstart", _handler, { passive: opts.passive });
  return {
    destroy() {
      node.removeEventListener("click", _handler);
      node.removeEventListener("touchstart", _handler);
    }
  };
};
var ScrollTo_default = scrollTo;

// node_modules/svelte-scrolling/dist/actions/ScrollRef.js
var scrollRef = (node, reference) => {
  if (!reference) {
    throw new Error("scrollRef require a reference");
  }
  const elementsList2 = get(elements);
  elementsList2.push({
    node,
    reference: sanitize(reference)
  });
  return {
    destroy() {
      elementsList2.length = 0;
    }
  };
};
var ScrollRef_default = scrollRef;

// node_modules/svelte-scrolling/dist/functions/scrolling.js
var scrollPosition = async (position, options) => {
  if (!position) {
    throw new Error("scrollPosition require a position value valid");
  }
  if (typeof position === "number") {
    position = { x: 0, y: position };
  }
  const endPosition = position;
  const _options = mergeGlobalOptions(options);
  const { duration, offset, onStart, onDone } = _options;
  onStart === null || onStart === void 0 ? void 0 : onStart({ offset, duration, endPosition });
  await scrolling_default(endPosition, _options);
  onDone === null || onDone === void 0 ? void 0 : onDone({ offset, duration, endPosition });
};
var scrollElement = async (reference, options) => {
  if (!reference || typeof reference !== "string") {
    throw new Error("scrollElement require a reference valid");
  }
  const ref = sanitize(reference);
  const elementsList2 = get(elements);
  const element = getElement(elementsList2, ref);
  if (!element) {
    throw new Error(`Element reference '${ref}' not found`);
  }
  const endPosition = getPosition(element);
  await scrollPosition(endPosition, mergeGlobalOptions(options));
};
var scrollTop = async (options) => {
  await scrollPosition({ x: 0, y: 0 }, mergeGlobalOptions(options));
};
var scrollBottom = async (options) => {
  const body = document.body;
  const html = document.documentElement;
  const endPosition = {
    x: 0,
    y: Math.max(body.scrollHeight, body.offsetHeight, html.scrollHeight, html.clientHeight, html.offsetHeight)
  };
  await scrollPosition(endPosition, mergeGlobalOptions(options));
};
var scrollLeft = async (options) => {
  await scrollPosition({ x: 0, y: 0 }, mergeGlobalOptions(options));
};
var scrollRight = async (options) => {
  const body = document.body;
  const html = document.documentElement;
  const endPosition = {
    x: Math.max(body.scrollWidth, body.offsetWidth, html.scrollWidth, html.clientWidth, html.offsetWidth),
    y: 0
  };
  await scrollPosition(endPosition, mergeGlobalOptions(options));
};
export {
  scrollBottom,
  scrollElement,
  scrollLeft,
  scrollPosition,
  ScrollRef_default as scrollRef,
  scrollRight,
  ScrollTo_default as scrollTo,
  scrollTop,
  globalOptions_default as setGlobalOptions
};
//# sourceMappingURL=svelte-scrolling.js.map
